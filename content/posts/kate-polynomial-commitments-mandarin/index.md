---
title: Kate Polynomial Commitments Mandarin
description: KZG 多项式承诺
slug: kate-polynomial-commitments-mandarin
date: 2023-09-07T22:39:33+08:00
featured: false
draft: false
comment: true
toc: true
reward: true
pinned: false
carousel: false
math: true
series: 
  - 以太坊中的密码学
categories:
  - ethereum
tags:
  - zkevm
  - zkp
  - commitments
  - cryptography
---

本文修正了 [KZG 多项式承诺](https://dankradfeist.de/ethereum/2021/10/13/kate-polynomial-commitments-mandarin.html) 中一些描述不好的部分，并添加一些前置知识的引用。

<!--more-->

## 简介

今天我想向你们介绍一下 Kate，Zaverucha 和 Goldberg 发表的 [多项式承诺方案](https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf)。这篇文章并不涉及复杂的数学及密码学理论知识，仅作为一篇简介。

该方案通常被称作卡特（Kate，读作 kah-tay）多项式承诺方案。在一个多项式承诺方案中，证明者计算一个多项式的承诺（commitment）, 并可以在多项式的任意一个点进行打开（opening）：该承诺方案能证明多项式在特定位置的值与指定的数值一致。

之所以被称为承诺，是因为当承诺值（椭圆曲线上的一个点）发送给某对象（验证者）后，证明者无法改变当前计算的多项式。他们只能为一个多项式提供有效的证明，如果他们试图作弊，他们将无法产生证明，或者证明将被验证者拒绝。

## 预备知识

如果你对有限域，椭圆曲线和配对这几个话题不是很熟悉的话，非常推荐去读一读 Vitalik Buterin 的 [探索椭圆曲线配对]({{< ref "../exploring-elliptic-curve-pairings" >}}) 的博客。

## 默克尔树对比

如果你已经熟知默克尔树，我想将之与卡特承诺进行对比。默克尔树即是密码学家所说的矢量承诺：使用深度为 $d$ 的默克尔树，你可以计算出对一个向量（即，固定长度的元素列表）$a_0, \ldots, a_{2^d-1}$ 的承诺 $a_0, \ldots, a_{2^d-1}$ 。运用熟知的默克尔证明，你可以用 $d$ 个哈希来提供证明元素 $a_i$ 存在于这个向量的位置 $i$ 。

事实上，我们可以用默克尔树来构造多项式承诺：回忆一下，一个 $n$ 次的多项式 $p(X)$ ，无非是一个函数 $p(X) = \sum_{i=0}^{n} p_i X^i$ ，其中 $p_i$ 是该多项式的系数。

通过设置 $a_i=p_i$，我们可以计算这一系列系数的默克尔树根，从而比较容易地对一个 $n = 2^d -1$ 次的多项式进行承诺。证明一个取值，意味着证明者想要向验证者展示对于某个值 z，$p(z)=y$。为达到这个目的，证明者可以向验证者发送所有的 $p_i$，然后验证者计算 $p(z)$ 是否等于 $y$。

当然，这是一个极度简单化的多项式承诺，但它能帮助我们理解真实的多项式承诺的益处。让我们一起回顾多项式承诺的性质：

1. 承诺的大小是一个单一哈希（默克尔树根）。一个足够安全的加密散列一般需要 256 位，即 32 字节。
2. 为了证明一个取值，证明者需要发送所有的 $p_i$，所以证明的大小和多项式次数是线性相关的。同时，验证者需要做同等的线性量级的计算（他们需要计算多项式在 z 点的取值，即计算 $p(z)=\sum_{i=0}^{n} p_i z^i$。
3. 该方案未隐藏多项式的任何部分 - 证明者一个系数接一个系数地发送完整的多项式。

现在让我们一起来看看卡特方案是如何达成以上要求的：

1. 承诺大小是一个支持配对的椭圆曲线群元素。比如说对于 BLS12_381 曲线，大小应是 48 字节。
2. 证明大小独立于多项式大小，永远是一个群元素。验证，同样独立于多项式大小，无论多项式次数为多少都只要两次群乘法和两次配对。
3. 大多数时候该方案隐藏多项式 - 事实上，无限多的多项式将会拥有完全一样的卡特承诺。但是这并不是完美隐藏：如果你能猜到多项式（比如说该多项式过于简单，或者可能的多项式集合很小），你就可以找到这个被承诺的多项式。

还有一点，在一个承诺中合并任意数量的取值证明是可行的。这些性质使得卡特方案对于零知识证明系统来说非常具有吸引力，例如 PLONK 和 SONIC。同时对于一些更日常的目的，或者简单的作为一个向量承诺来使用也是非常有趣的场景，接下来的文章中我们就会看到。

## 椭圆曲线以及配对

正如之前所提到的预备知识所说，我强烈推荐 Vitalik Buterin 的博客：[探索椭圆曲线配对]({{< ref "../exploring-elliptic-curve-pairings" >}})。它包含了理解本文所需的背景知识：特别是有限域，[椭圆曲线]({{< ref "../elliptic_curve" >}}) 和配对相关知识。

假设 $G_1$ 和 $G_2$是两条椭圆曲线，并满足配对 $e: \mathbb G_1 \times \mathbb G_2 \rightarrow \mathbb G_T$ ，假设 $p$ 是 $G_1$ 和 $G_2$ 的阶，$G$ 和 $H$ 是 $G_1$ 和 $G_2$ 的生成元。接下来，我们定义一个非常有效的速记符号：对于任意 $x∈F_p$:

$$
[x]_1 = x G \in \mathbb G_1 \text{ and } [x]_2 = x H \in \mathbb G_2
$$

## 可信设置

假设我们已有一个可信设置，使得对于一个秘密 $s$，其子元素 $[s^i]_1$ 和 $[s^i]_2$ （ $i=0, \ldots, n-1$ ）对于任意的证明者和验证者都可用。

有一种方法能够获得这种可信设置：我们用离线计算机生成一个随机数 $s$，计算所有的群元素 $[s^i]_x$，并通过电线传输出去（不包括 $s$）, 然后烧掉这部计算机。当然这并不是一个好的解决方案，你必须相信计算机的操纵者没有通过其他渠道泄露这个秘密 $s$。

在实际应用中，这种设置通常采用安全多方计算（MPC），使用一组计算机来创建这个群元素，而没有任何单一计算机知道秘密 $s$，这样只有挟持了整组计算机才能知道 $s$。

注意这里有一件事是不可能的：你不能仅仅选择一个随机群元素 $[s]_1$（其中 $s$ 是未知的）然后通过它计算其他的群元素。不知道 $s$ 是无法计算 $[s^2]_1$ 的。

好了，椭圆曲线密码学基础告诉我们通过可信设置的群元素是无法破解 $s$ 的，它是有限域 $F_p$ 中的一个数字，但证明者无法找出它的具体数值。他们只能在给定的元素上做一些特定的计算。举个例子，他们可以用椭圆曲线乘法轻易地计算 $c [s^i]_1 = c s^i G = [cs^i]_1$，或者说将椭圆曲线点值相加算出 $\displaystyle c [s^i]_1 + d [s^j]_1 = (c s^i + d s^j) G = [cs^i + d s^j]_1$ 。实际上如果

$$
p(X) = \sum_{i=0}^{n} p_i X^i
$$

是一个多项式，证明者可以计算：

$$
\lbrack\sum_{i=0}^{n}{p_i}{s^i}\rbrack \\\\
[p(s)]_1={}_1
$$

这就显得非常有趣 – 通过使用这套可信设置，任何人都可以计算出一个多项式在一个谁也不知道的秘密点 s 上的值。只是他们得到的输出值不是一个自然数，而是一个椭圆曲线点 $[p(s)]_1 = p(s) G$ ，这已经足够有用。
