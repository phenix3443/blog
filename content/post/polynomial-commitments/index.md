---
title: "Polynomial Commitments"
description: 多项式承诺
slug: polynomial-commitments
date: 2023-04-03T00:53:54+08:00
image:
math:
license:
hidden: false
comments: true
draft: false
categories:
  - ethereum
tags:
  - commitments
  - cryptography
---

## 密码学中的承诺

### 猜拳游戏[^4]

猜拳游戏往往因为“慢出” 产生争执，在不引入可信任的第三方情况下，一个最简单的解法是： 每人把自己的决定（石头、剪刀、布）写到一张纸上。再装进一个信封里。然后两人见面，把信封拆开。这样就无法改变自己的决定了。这样的猜拳结果是完全公平的，因为决定已经装在信封里，就无法再更改了！

这个过程中，写在纸上就相当于是做承诺；拆开信封对应密码学中所谓的揭示承诺。

难度提高一点: 假设诸葛亮想和曹操猜拳，但是两人身处异地无法见面。这种情况下如何保证公平呢？

如果诸葛亮把自己的信封用快马送给曹操，那曹操可以拆开看到诸葛亮的出拳之后再写自己的信。所以之前的解法就失效了。

信封这个解法不行了，不过如果用一点密码学，还是可以异地猜拳。我们假设猜拳选择，石头、剪刀、布可以分别对应整数 0,1,2。有一个抗碰撞的哈希函数(collision-resistant hash function) f(x)，满足如下的条件：

1. 从 x 很容易计算 f(x)。
2. 非常难找到两个 x, y 满足 f(x) = f(y).

接下来：

1. 诸葛亮先从石头、剪刀、布确定一个选择 m 。然后再选择一串随机数 r，把自己的承诺 y1(`y1 = f(r1 , m1)`) 发给曹操。曹操同样把自己的选择 y2(`y2 = f(r2 , m2)`) 发给诸葛亮。

2. 诸葛亮等自己收到曹操的承诺 y2 以后，再把随机数 r1 和自己的选择 m1 发送过去。曹操等收到承诺之后，做同样的事。

3. 曹操通过计算 `f(r1, m1) = y1` 来确保诸葛亮没有作弊，诸葛亮也做同样的事情。

现在双方可以比较彼此的出拳选择 m1 和 m2，来决定谁胜谁负！问题是: 为什么这样可以杜绝一方作弊？

假设诸葛亮想要作弊，那他必须在收到曹操的所有信息之后再发送（r1, m1）。现在假设诸葛亮想把自己的选择改成 m1' , 那么他必须找到另一个随机数 r1'，满足

`f(r1 , m1) = f(r1', m1')`

然而， 根据对函数 f 的假设，诸葛亮是找不到 r1' 的。所以他没有办法作弊：任何他能找到的 r1'，曹操计算出的承诺 `f(r1', m1')` 都和 y1 对不上，所以曹操能看出他有没有“慢出”！

### 承诺方案(commitment Scheme)

上面介绍的“公平的远程猜拳”方法用到的实际是密码学的一个重要原型：[承诺方案(Commitment Scheme)](https://en.wikipedia.org/wiki/Commitment_scheme)。它起源于两篇文章：

- 1979 年 Blum 的 [通电话猜硬币(coin flipping over the telephone)](https://dl.acm.org/doi/10.1145/1008908.1008911)
- 1981 年 RSA 三巨头的 [通电话玩扑克(Mental Poker)](https://en.wikipedia.org/wiki/Mental_poker)。

可以看出来，commitment 最大的优势是用来远程进行公平的博弈，而不需要一个第三方裁判的存在。

密码学承诺方案是一个涉及两方的二阶段交互协议，双方分别为承诺方和接收方。

- 第一阶段为承诺(Commit)阶段，承诺方选择随机数 r，和消息 m 生成`承诺(commitment)`，并将承诺发送给接收方，`意味着自己不会更改 m`。
- 第二阶段为揭示(Reveal)阶段，承诺方公开消息 m 与随机数 r，接收方据此计算来验证其得出的承诺值与上一阶段所接收的承诺是否一致，进而可以知道`判断承诺方是否修改了消息 m`。

承诺方案有两个基本性质：`隐藏性(Hiding)`和`绑定性(Binding)`。

- 隐藏性：第一阶段，承诺值不会泄露任何关于消息 m 的信息。
- 绑定性：任何恶意的承诺方都不能修改 m 后还可以生成与第一阶段相同的承诺来让验证通过，即接收方可以确信 m 是和该承诺对应的消息。

## 哈希承诺

哈希承诺，用户可以通过以下公式计算关于敏感数据 v 的承诺，其中 H 是一个密码学安全的单向哈希算法。

`c = H(v)`

简而言之，哈希算法是一个单向不可逆且对输入敏感的算法。以此为例，对于不同的输入 v，得到的哈希结果 c 也是不同，准确的说，随机输入一个 v,得到的唯一的 c 是均匀分布的，且无法预测即抗碰撞性。

基于单向哈希的单向性，难以通过哈希值 H(v)反推出敏感数据 v，提供了一定的隐匿性；基于单向哈希的抗碰撞性，难以找到不同的敏感数据 v'产生相同的哈希值 H(v)，以此提供了一定的绑定性。

举例说明，我有一篇文章将其哈希后结果作为该篇文章的承诺公开，之后任何人要求验证我的承诺，OK，我把原始文章拿出来，对方做一次哈希得到结果等于之前承诺，证明承诺为真。如果我没有那篇文章或者说用别的文章代替，那么哈希结果会发生变化，这样的作弊行为就无法通过验证。这种形式可以作为版权证明的一种方式。

哈希承诺的构造简单、使用方便，满足密码学承诺基本的特性，适用于对隐私数据机密性要求不高的应用场景。

对隐私数据秘密性要求高的场合，哈希承诺提供的隐匿性比较有限，不具备随机性。对于同一个敏感数据 v，H(v)值总是固定的，因此理论上可以通过暴力穷举，列举所有可能的 v 值，来反推出 H(v)中实际承诺的 v（注：安全性高的哈希函数目前算力破解还很难）。

另外，哈希承诺不具有在密文形式对其处理的附加功能，例如，多个相关的承诺值之间密文运算和交叉验证，对于构造复杂密码学协议和安全多方计算方案的作用比较有限。

## Merkle 树承诺

Merkle 树是一种典型的二叉树结构，由一组叶节点，一组中间节点和一个根节点组成见下图，Merkle 树最早由 Merkle Ralf 在 1980 年提出，曾广泛用于文件系统和 P2P 系统中。

![merkle](img/merkle.webp)

其主要特点为：

- 最下面的叶子节点包含存储数据(或哈希值),非叶子节点（包括中间节点和根节点）都是它的两个孩子节点内容的哈希值。
- Merle 树逐层记录哈希值的特点，让它具有了一些独特的性质。例如，底层数据的任何变动，都会传递到其父节点，一层层沿着路径一直到树 root。这意味 root 根的值实际上代表了对底层所有数据的“数字摘要”。
  进一步地，Merkle 树可以推广到多叉树的情形，此时非叶子节点的内容为它所有的孩子节点的内容的哈希值。

## 多项式承诺

### 多项式[^1]

多项式(Polynomial)是代数学中的基础概念, 是由称为未知数的`变量`和称为`系数`的常数通过有限次加减法, 乘法以及自然数幂次的乘方运算得到的代数表达式[^2]。以单变量多项式为例说明：

![系数表示法](img/1.png)

以上是系数表示形式，系数序列确定多项式也就确定了。还有一种表示方法是使用 n+1 点值对表示 n 次多项式。

![点值对表示法](img/2.png)

同样，这种方法也能唯一确定多项式。

两种表示方法，各有其应用场景，比如系数表示法在计算多项式相加的场合效率高，而点值表示法则应用在多项式相乘计算场合。

由于两种表示法本质是同一个东西，所以二者可以相互转化，其中 FFT 就是实现系数表达到点值表示的转换方法，而 IFFT 正好相反。关于 FFT 和 IFFT 深入解读超出本文范围，可自行查阅[^3]。

### 将数据编码为多项式

对于一段二进制数据，如果我们按照 32bytes 进行分组，那么可以将可以转化为数组[y0,y1,y2...yn]，yn 可以使用整数表示。

如果将数组下标看做是[x0,x1...xn]，那么我们可以点值`(x0,y0),(x1,y1)...(xn,yn)`来代表这段二进制数据。

我们可以通过[多项式差值](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC)或者[多项式拟合](https://zh.wikipedia.org/zh-cn/%E6%9B%B2%E7%B7%9A%E6%93%AC%E5%90%88)将这些点值对编码为一个多项式（比如[consensus-specs 中使用的方法](https://github.com/ethereum/consensus-specs/blob/23d3aeebba3b5da0df4bd25108461b442199f406/specs/eip4844/polynomial-commitments.md#blob_to_polynomial)）。对于任意的 xn，都可以通过这个多项式计算出对应的 yn。

多项式承诺(polynomial commitments)就是将数据编码为多项式后，通过多项式特性来验证数据是否发生改变的方法。

![kzg](https://www.chaincatcher.com/upload/image/20230130/1675042608317730.jpg)

### 基于多项式的承诺

多项式承诺有多种方式，比如最直接的就是把多项式系数承诺出去，这样`多项式在承诺后就不能再改变了`，也就意味着数据不再改变了。这种方式在系数较少即多项式度数较低时适用。当系数比较多（比如超过 10 万）承诺结果就会比较大，增加存储与传输的代价。能不能用点值方式做承诺呢？最好适用一个点的值，因为点值用的多了同样也会有上述问题。

一个原始的点值承诺方法浮出水面：

### 全部揭示

- 承诺(Commit)阶段：

  承诺方选择一个暂不公开的多项式，在某一点 r 处，计算出对应的承诺 c(`c = f(r)`) 并公开, 将`(r,c)`公开给验证方。

- 揭示(Reveal)阶段：

  承诺方公布多项式，验证方根据多项式计算 r 处值 c' = f(r)，比较 c'= c，一致则表示验证成功，否则失败。

这种原始承诺方式有问题吗？仔细想想容易发现有以下问题：

在 r 处取值为 c 的多项式存在多个，比如 `f(r) = c`, `g(r) = c` ,那么承诺方就可以在承诺时候使用多项式 f(x), 而在验证阶段使用 g(x) 也能通过验证，这样就达不到承诺的目的了。

### 部分揭示

上面这种把多项式和盘托出的揭示方式成为`全部揭示`，还有一种`部分揭示`的方式：

- 承诺(Commit)阶段：

  承诺方选择一个暂不公开的多项式，在某一点 r 处，计算出对应的承诺 c 并公开。c = f(r), 将（r，c）公开给验证方。

- 挑战（challenge）与证明生成：

  验证方 V 随机选择一个数 z,发给承诺方, 承诺方计算在 z 处值 s = f(z)，同时使用多项式 `t(x) = (f(x)-s)/ (x-z)`，计算 t(x)在 z 处的值 w = t(z) (w 也称为见证 witness)，将 `(s,w)` 返回给验证方。

- 揭示(Reveal)阶段：

  验证方验证：s = f(z) --> f(z) - s = 0 --> 方程 f(x)-s = 0 有根 x=z, 即存在 t(x) 使得 f(x) - s = t(x)(x - z), 这个方程是恒等式，所以任意点都成立。

  在 r 处自然也是成立的，所以可以检验 f(r) - s = t(r)(r - z) --> c - s = w(r - z ) 通过则验证成功，否则失败。

这种方法采用部分揭示方式验证，使得多项式增加了隐私性，自始至终没有完全暴露最初的多项式。现在已经比较接近 Kate 承诺的方案了。

![Partial reveal](img/partial-reveal.webp)

### 应用场景[^6]

上面的 Merkle 树如果说有其不足之处的话，当叶子节点的数量级非常大，树层级数变多，在打开验证节点需要的 merkle 树证明路径也就越长，数据量就越大，相对于此，前文描述的多项式承诺没有这个问题，所以 Vitalik 的一篇文章：
[Using polynomial commitments to replace state roots](https://ethresear.ch/t/using-polynomial-commitments-to-replace-state-roots/7095)([中文版](https://www.8btc.com/article/567865)) 畅想以后可能考虑使用多项式承诺代替现在已有的 merkle 树承诺。

多项式承诺应用方向总结起来可以分为 3 大类：

- 数据可用性（ETH Surge 升级，ETH danksharding，降低 L2 成本，模块化数据可用性项目 Avails）
- 数据结构优化（MPT 树改为 Verkle 树，ETH Verge 升级，无状态客户端，实现 ETH 的轻量的验证节点）
- 零知识证明系统（Zksync，Zkswap，Scroll，PSE 给 Zk 提供多项式承诺方案，大大提升链的拓展能力）

### 实现[^5]

![compare](img/compare.png)

上表中：

- FRI 是 Starkware 采用的多项式承诺方案，可以实现量子级别的安全，但证明的数据量却是最大；
- IPA 是 Bulletproof 和 Halo2 零知识算法默认的多项式承诺方案，验证时间相对较长，采用的项目有门罗币，zcash 等，前两者是不需要初始可信设置的。
- 在证明大小与验证时间上，KZG 多项式承诺的优势比较大，KZG 承诺也是目前应用最广的一种多项式承诺方式。但 KZG 是基于椭圆曲线，配对函数，需要初始可信设置的。

## 延伸阅读

- [Polynomial Commitments](https://cacr.uwaterloo.ca/techreports/2010/cacr2010-10.pdf)
- [多项式运算](http://accu.cc/content/cryptography/polynomial_math/)
- [Vitalik：以太坊状态爆炸问题，多项式承诺方案可解决](https://www.8btc.com/article/567865) 建议阅读。

## 参考

[^1]: [区块链中的数学 - 多项式承诺](https://learnblockchain.cn/article/2165)
[^2]: [多项式](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A0%85%E5%BC%8F)
[^3]: [FFT/IFFT 快速傅里叶变换](https://oi-wiki.org/math/poly/fft/)
[^4]: [用一点密码学实现远程猜拳 -- 闲聊 commitment scheme](https://zhuanlan.zhihu.com/p/25241252)
[^5]: [多项式承诺 Polynomial commitment 方案汇总](https://blog.csdn.net/mutourend/article/details/125922653)
[^6]: [多项式承诺，正在重塑整个区块链](https://web3caff.com/zh/archives/38949)
