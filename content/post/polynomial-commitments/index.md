---
title: "Polynomial Commitments"
description: 多项式承诺
slug: polynomial-commitments
date: 2023-04-03T00:53:54+08:00
image:
math:
license:
hidden: false
comments: true
draft: true
categories:
  - ethereum
tags:
  - kzg
---

## 密码学中的承诺

### 猜拳游戏[^4]

猜拳游戏往往因为“慢出” 产生争执，在不引入可信任的第三方情况下，一个最简单的解法是： 每人把自己的决定（石头、剪刀、布）写到一张纸上。再装进一个信封里。然后两人见面，把信封拆开。这样就无法改变自己的决定了。这样的猜拳结果是完全公平的，因为决定已经装在信封里，就无法再更改了！

这个过程中，写在纸上就相当于是做承诺；拆开信封对应密码学中所谓的揭示承诺。

难度提高一点: 假设诸葛亮想和曹操猜拳，但是两人身处异地无法见面。这种情况下如何保证公平呢？

如果诸葛亮把自己的信封用快马送给曹操，那曹操可以拆开看到诸葛亮的出拳之后再写自己的信。所以之前的解法就失效了。

信封这个解法不行了，不过如果用一点密码学，还是可以异地猜拳。我们假设诸葛亮有一个抗碰撞的哈希函数(collision-resistant hash function) f(x)，满足如下的条件：

1. 从 x 很容易计算 f(x)。
2. 非常难找到两个 x, y 满足 f(x) = f(y).

接下来：

1. 诸葛亮先从石头、剪刀、布确定一个选择 m 。然后再选择一串随机数 r，把自己的承诺 y1(`y1 = f(r1 , m1)`) 发给曹操。曹操同样把自己的选择 y2(`y2 = f(r2 , m2)`) 发给诸葛亮。

2. 诸葛亮等自己收到曹操的承诺 y2 以后，再把随机数 r1 和自己的选择 m1 发送过去。曹操等收到承诺之后，做同样的事。

3. 曹操通过计算 `f(r1, m1) = y1` 来确保诸葛亮没有作弊，诸葛亮也做同样的事情。

现在双方可以比较彼此的出拳选择 m1 和 m2，来决定谁胜谁负！问题是: 为什么这样可以杜绝一方作弊？

假设诸葛亮想要作弊，那他必须在收到曹操的所有信息之后再发送（r1, m1）。现在假设诸葛亮想把自己的选择改成 m1' , 那么他必须找到另一个随机数 r1'，满足

`f(r1 , m1) = f(r1', m1')`

然而， 根据对函数 f 的假设，诸葛亮是找不到 r1' 的。所以他没有办法作弊：任何他能找到的 r1'，曹操计算出的承诺 `f(r1', m1')` 都和 y1 对不上，所以曹操能看出他有没有“慢出”！

### 承诺方案(commitment Scheme)

上面介绍的”公平的远程猜拳“方法用到的实际是密码学的一个重要原型：[承诺方案(Commitment Scheme)](https://en.wikipedia.org/wiki/Commitment_scheme)。它起源于两篇文章：

- 1979 年 Blum 的 [通电话猜硬币(coin flipping over the telephone)](https://dl.acm.org/doi/10.1145/1008908.1008911)
- 1981 年 RSA 三巨头的 [通电话玩扑克(Mental Poker)](https://en.wikipedia.org/wiki/Mental_poker)。

可以看出来，commitment 最大的优势是用来远程进行公平的博弈，而不需要一个第三方裁判的存在。

密码学承诺方案是一个涉及两方的二阶段交互协议，双方分别为承诺方和接收方。

- 第一阶段为承诺(Commit)阶段，承诺方选择随机数 r，和消息 m 生成`承诺(commitment)`，并将承诺发送给接收方，`意味着自己不会更改 m`。
- 第二阶段为揭示(Reveal)阶段，承诺方公开消息 m 与随机数 r，接收方据此计算来验证其得出的承诺值与上一阶段所接收的承诺是否一致，进而可以知道`判断承诺方是否修改了消息 m`。

承诺方案有两个基本性质：`隐藏性(Hiding)`和`绑定性(Binding)`。

- 隐藏性：第一阶段，承诺值不会泄露任何关于消息 m 的信息。
- 绑定性：任何恶意的承诺方都不能修改 m 后还可以生成与第一阶段相同的承诺来让验证通过，即接收方可以确信 m 是和该承诺对应的消息。

## 多项式[^1]

多项式(Polynomial)是代数学中的基础概念, 是由称为未知数的`变量`和称为`系数`的常数通过有限次加减法, 乘法以及自然数幂次的乘方运算得到的代数表达式[^2]。以单变量多项式为例说明：

![系数表示法](img/1.png)

以上是系数表示形式，系数序列确定多项式也就确定了。还有一种表示方法是使用 n+1 点值对表示 n 次多项式。

![点值对表示法](img/2.png)

同样，这种方法也能唯一确定多项式。

两种表示方法，各有其应用场景，比如系数表示法在计算多项式相加的场合效率高，而点值表示法则应用在多项式相乘计算场合。

由于两种表示法本质是同一个东西，所以二者可以相互转化，其中 FFT 就是实现系数表达到点值表示的转换方法，而 IFFT 正好相反。关于 FFT 和 IFFT 深入解读超出本文范围，可自行查阅[^3]。

## 多项式承诺

我们可以通过[多项式差值](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC) 或者[多项式拟合](https://zh.wikipedia.org/zh-cn/%E6%9B%B2%E7%B7%9A%E6%93%AC%E5%90%88)等方法，使用多项式代表一组数据，也就是说通过系数表示法或者点值对表示法代表这组数据。

进而，如果我们需要保证没有改变数据，只需要保证多项式没有改变即可。

多项式承诺(polynomial commitments) 有多种方式，比如最直接的就是把多项式系数承诺出去，这样`多项式在承诺后就不能再改变了`。 这种方式在系数较少即多项式度数较低时适用。

当系数比较多（比如超过 10 万）承诺结果就会比较大，增加存储与传输的代价。能不能用点值方式做承诺呢？最好适用一个点的值，因为点值用的多了同样也会有上述问题。

一个原始的点值承诺方法浮出水面：

### 全部揭示

- 承诺生成（Commit）阶段：

  承诺方选择一个暂不公开的多项式，在某一点 r 处，计算出对应的承诺 c 并公开。`c = f(r)`, 将`(r,c)`公开给验证方

- 承诺揭示（Reveal）阶段：

  承诺方公布多项式，验证方根据多项式计算 r 处值 c' = f(r)，比较 c'= c，一致则表示验证成功，否则失败。

这种原始承诺方式有问题吗？仔细想想容易发现有以下问题：

在 r 处取值为 c 的多项式存在多个，比如 `f(r) = c`, `g(r) = c` ,那么承诺方就可以在承诺时候使用多项式 f(x), 而在验证阶段使用 g(x) 也能通过验证，这样就达不到承诺的目的了。

### 部分揭示

上面这种把多项式和盘托出的揭示方式成为`全部揭示`，还有一种`部分揭示`的方式：

- 承诺生成（Commit）阶段：

  承诺方选择一个暂不公开的多项式，在某一点 r 处，计算出对应的承诺 c 并公开。c = f(r), 将（r，c）公开给验证方

- 挑战（challenge）与证明生成：

  验证方 V 随机选择一个数 z,发给承诺方 P, P 计算在 z 处值 s = f(z)，同时计算出 t(x) = f(x)-s / (x-z),计算 t(x)在 z 处的值 w = t(z)(w 也称为见证 witness) 返回给验证方 V(s,w)

- 验证阶段：

  验证方验证：s = f(z) --> f(z) - s = 0 --> 方程 f(x)-s = 0 有根 x=z, 即存在 t(x) 使得 f(x) - s = t(x)(x - z), 这个方程是恒等式，所以任意点都成立。

  在 r 处自然也是成立的，所以可以检验 f(r) - s = t(r)(r - z) = c - s = w(r - z ) 通过则验证成功，否则失败。

这种方法采用部分揭示方式验证，使得多项式增加了隐私性，自始至终没有完全暴露最初的多项式。现在已经比较接近 Kate 承诺的方案了

## 应用场景

多项式承诺应用方向总结起来可以分为 3 大类

- 数据可用性（ETH Surge 升级，ETH danksharding，降低 L2 成本，模块化数据可用性项目 Avails）
- 数据结构优化（MPT 树改为 Verkle 树，ETH Verge 升级，无状态客户端，实现 ETH 的轻量的验证节点）
- 零知识证明系统（Zksync，Zkswap，Scroll，PSE 给 Zk 提供多项式承诺方案，大大提升链的拓展能力）

## 承诺方案

![compare](img/compare.png)

上表中：

- FRI 是 Starkware 采用的多项式承诺方案，可以实现量子级别的安全，但证明的数据量却是最大；
- IPA 是 Bulletproof 和 Halo2 零知识算法默认的多项式承诺方案，验证时间相对较长，采用的项目有门罗币，zcash 等，前两者是不需要初始可信设置的。
- 在证明大小与验证时间上，KZG 多项式承诺的优势比较大，KZG 承诺也是目前应用最广的一种多项式承诺方式。但 KZG 是基于椭圆曲线，配对函数，需要初始可信设置的。

## 参考

- [多项式承诺，正在重塑整个区块链](https://web3caff.com/zh/archives/38949)
- [多项式承诺 Polynomial commitment 方案汇总](https://blog.csdn.net/mutourend/article/details/125922653)
- [区块链中的数学 - 多项式承诺](https://learnblockchain.cn/article/2165)
- [Vitalik：以太坊状态爆炸问题，多项式承诺方案可解决](https://www.8btc.com/article/567865) 建议阅读。

[^1]: [多项式运算](http://accu.cc/content/cryptography/polynomial_math/)
[^2]: [多项式](https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A0%85%E5%BC%8F)
[^3]: [FFT/IFFT 快速傅里叶变换](https://oi-wiki.org/math/poly/fft/)
[^4]: [用一点密码学实现远程猜拳 -- 闲聊 commitment scheme](https://zhuanlan.zhihu.com/p/25241252)
