---
title: "合约应用二进制接口"
slug: contract-abi-encode
description:
date: 2022-07-05T13:37:48+08:00
slug: contract-abi
image:
math:
license:
hidden: false
comments: true
draft: false
tag:
    - ethereum
    - hive
    - test
---

## 概述

以太坊合约应用二进制接口 (ABI) 是在以太坊生态系统中与合约交互的标准方式，既可以从区块链外部进行，也可以用于合约间交互。数据根据其类型进行编码。由于编码不是自描述的，因此需要一个说明（也就是 `abi.json`）才能解码。更多参见[合约 ABI 规范](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#basic-design)。

Golang 的 [abi package](https://pkg.go.dev/github.com/ethereum/go-ethereum/accounts/abi#pkg-overview) 实现了以上规范，通过该 package 不仅可以根据 abi.json 与合约交互，还有对多个参数进行自定义编码。

合约接口相关的操作可通过 [abi.ABI](https://pkg.go.dev/github.com/ethereum/go-ethereum/accounts/abi#ABI) 可用来根据 `abi.json` 编码合约接口。

## 参数类型

首先，需要通过 [NewType](https://github.com/ethereum/go-ethereum/blob/v1.10.26/accounts/abi/type.go#L70) 定义参数 abi 类型。

```go
// NewType creates a new reflection type of abi type given in t.
func NewType(t string, internalType string, components []ArgumentMarshaling) (typ Type, err error)
```

+ `t` 是 [abi 接口规范支持的类型](https://docs.soliditylang.org/en/v0.8.13/abi-spec.html#types)，有两个测试用例可以参考：
  + [TestTypeRegexp](https://github.com/ethereum/go-ethereum/blob/c4a662176ec11b9d5718904ccefee753637ab377/accounts/abi/type_test.go#L33) 描述了 t 字段的表达式。
  + [TestTypeCheck](https://github.com/ethereum/go-ethereum/blob/c4a662176ec11b9d5718904ccefee753637ab377/accounts/abi/type_test.go#L119) 描述了 t 字段与 golang 类型映射关系。
+ `internalType` 是 solidity 0.5.10 开始引入的一个 abi 字段，具体解释参见[What is the purpose of `internalType` now generated by the Solidity compiler in ABIs?](https://ethereum.stackexchange.com/questions/76953/what-is-the-purpose-of-internaltype-now-generated-by-the-solidity-compiler-in)，对于 encode/decode 没有影响，常设置为空字符串即可。
+ `components` 用于定义符合字段，常用来定义 struct 中的 fields。

### 基础类型

```go

var (
    int8Type, _    = abi.NewType("int8", "", nil)
    uint8Type, _   = abi.NewType("uint8", "", nil)
    boolType, _    = abi.NewType("bool", "", nil)
    addressType, _ = abi.NewType("address", "", nil)
    strType, _     = abi.NewType("string", "", nil)
    byte32Type, _  = abi.NewType("bytes", "", nil)
    bytesType      = abi.Type{T: abi.BytesTy}
)
```

### 数组

```go
    int8ArrayType, _ = abi.NewType("int8[3]", "int8", nil)
    strArrayType, _  = abi.NewType("string[]", "string", nil)
```

### struct

```go
    personType, _ = abi.NewType("tuple", "", []abi.ArgumentMarshaling{
        // abi.ArgumentMarshaling 对应 struct field
        {
            Name: "name", // 将来会作为 struct json tag
            Type: "string",
        },
        {
            Name: "address",
            Type: "address",
        },
        {
            Name: "father",
            Type: "tuple",
            Components: []abi.ArgumentMarshaling{
                {
                    Name: "name",
                    Type: "string",
                },
                {
                    Name: "address",
                    Type: "address",
                },
            },
        },
        {
            Name: "contact",
            Type: "tuple[]", // 如果 type=="tuple[]",Components 定义的就是数组元素的类型。
            Components: []abi.ArgumentMarshaling{
                {
                    Name: "name",
                    Type: "string",
                },
                {
                    Name: "address",
                    Type: "address",
                },
            },
        },
    })
```

## 编码解码 {#encode-arguments}

```go
var (
    personType, _ = abi.NewType("tuple", "Person", []abi.ArgumentMarshaling{
        {
            Name: "name", // 对应的字段名字要大写
            Type: "string",
        },
        {
            Name: "address",
            Type: "address",
        },
        {
            Name: "father",
            Type: "tuple", // 如果 type=="tuple",Components 定义的就是 struct 成员类型。
            Components: []abi.ArgumentMarshaling{
                {
                    Name: "name",
                    Type: "string",
                },
                {
                    Name: "address",
                    Type: "address",
                },
            },
        },
        {
            Name: "contact",
            Type: "tuple[]", // 如果 type=="tuple[]",Components 定义的就是数组元素的类型。
            Components: []abi.ArgumentMarshaling{
                {
                    Name: "name",
                    Type: "string",
                },
                {
                    Name: "address",
                    Type: "address",
                },
            },
        },
    })

    args = abi.Arguments{
        abi.Argument{
            Name: "person",
            Type: personType,
        },
    }
)

type Person struct {
    Name    string
    Address common.Address
}

var (
    alice = &Person{
        Name:    "alice",
        Address: common.HexToAddress("0x0001"),
    }
    bob = &Person{
        Name:    "bob",
        Address: common.HexToAddress("0x0002"),
    }
    args = abi.Arguments{
        {
            Name: "name",
            Type: strType,
        },
        {
            Name: "age",
            Type: int8Type,
        },
        {
            Name: "sex",
            Type: bytesType,
        },
        {
            Name: "teachers",
            Type: strArrayType,
        },
        {
            Name: "person",
            Type: personType,
        },
    }
)

// 测试编码
func TestABI(t *testing.T) {
    packed, err := args.Pack("alice", int8(10), []byte("female"), []string{"bob", "john"}, bob)
    assert.Nil(t, err)

    unpacked, err := args.Unpack(packed)
    assert.Nil(t, err)

    res := struct {
        Name     string
        Age      int8
        Sex      []byte
        Teachers []string
        Person   Person
    }{}

    err = args.Copy(&res, unpacked)
    assert.Nil(t, err)
    assert.EqualValues(t, *bob, res.Person)
}
```

